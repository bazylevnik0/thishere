<html>
<head>
</head>
<body>
</body>
</body>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            #player {
              position: absolute;
              z-index: 1;
          }
           #rendercanvas {
              position: absolute;
              z-index: 2;
          }

	#upload {
    position: absolute;
    height: 500px;
    top: 500px;
    z-index: 8;
}

	#div_drop {
	position: absolute;
	z-index: 3;
}
	#drop {
	position: absolute;
	z-index: 3;
}

#return {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 150px;
    left: 45%;
}


        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
	<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>
<video id="player" controls width="100%" height="100%" autoplay="true"></video>
<script>
  var player = document.getElementById('player');

  var handleSuccess = function(stream) {
    player.srcObject = stream;
  };

  navigator.mediaDevices.getUserMedia({ audio: false, video: true }).then(handleSuccess)
</script>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>

	
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        // Add your code here matching the playground format

	var scene = new BABYLON.Scene(engine);
       scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
	var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
	camera.attachControl(canvas, true);

	var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

	// Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
                scene.render();
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });


	//upload
	function loadFiles () {
		console.log("loadFiles")
	
	//important! we must check real size and correct this 
		//maybe we must correct link obj to mtl
		//if obj not zero element we need find obj!
		BABYLON.SceneLoader.ImportMeshAsync("", files[0].webkitRelativePath , files[0].name).then((result) => {
    		console.log(result.meshes)
		result.meshes[1].scaling.x = 0.25;
    		result.meshes[1].scaling.y = 0.25;
    		result.meshes[1].scaling.z = 0.25;
    		var myMesh1 = scene.getMeshByName("myMesh_1");
		console.log(result)
	})
	
	}
    </script>

<form id="upload" method="post" enctype="multipart/form-data">
 <div>
   <label for="files">Choose file to upload</label>
   <input type="file" id="files" name="files" multiple onchange="readFiles()" webkitrelativepath="true">
 </div>
 <div>
   <button>Submit</button>
 </div>
</form>


<div id="div_drop" ondrop="drop(event)" ondragover="allowDrop(event)"></div>

<img id="drop" src="img_logo.gif" draggable="true" ondragstart="drag(event)" width="336" height="69">

<script>
	 upload_form = document.getElementById('upload');
   
//drag and drop
function allowDrop(ev) {
  ev.preventDefault();
}

function drag(ev) {
  ev.dataTransfer.setData("text", ev.target.id);
}

function drop(ev) {
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  ev.target.appendChild(document.getElementById(data));
}

//input 
var files , reader
function readFiles() {
    console.log("readFiles")
	// this png 
	// this obj
		   //?

    files = document.getElementById('files').files;
    console.log(files)

    let temp;
    for(let i = 0; i < files.length; i++) {
   	console.log(files[i].name , files[i].webkitRelativePath)
    }
  
    editMode();
    loadFiles();
}
</script>
<button id="return" onclick="returnClick()">return</button>
<script>
	let return_button = document.getElementById('return')
	function returnClick() {
  		document.getElementById('files').value = "";
		scene.meshes = scene.meshes.constructor();
		uploadMode();
	}
</script>
   </body>
<script>
	function editMode() {
		upload_form.style.zIndex=0
		return_button.style.zIndex=8
		console.log("editMode")
	}

	function uploadMode() {
		upload_form.style.zIndex=8
		return_button.style.zIndex=0
		console.log("uploadMode")

	}

	let adt = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    let xAddPos = 0;
    let yAddPos = 0;
    let xAddRot = 0;
    let yAddRot = 0;
    let sideJoystickOffset = 150;
    let bottomJoystickOffset = -50;
    let translateTransform;    


  let leftThumbContainer = makeThumbArea("leftThumb", 2, "blue", null);
      leftThumbContainer.height = "200px";
      leftThumbContainer.width = "200px";
      leftThumbContainer.isPointerBlocker = true;
      leftThumbContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      leftThumbContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
      leftThumbContainer.alpha = 0.4;
      leftThumbContainer.left = sideJoystickOffset;
      leftThumbContainer.top = bottomJoystickOffset;

  let leftInnerThumbContainer = makeThumbArea("leftInnterThumb", 4, "blue", null);
      leftInnerThumbContainer.height = "80px";
      leftInnerThumbContainer.width = "80px";
      leftInnerThumbContainer.isPointerBlocker = true;
      leftInnerThumbContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
      leftInnerThumbContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;


  let leftPuck = makeThumbArea("leftPuck",0, "blue", "blue");
          leftPuck.height = "60px";
          leftPuck.width = "60px";
          leftPuck.isPointerBlocker = true;
          leftPuck.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
          leftPuck.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;


      leftThumbContainer.onPointerDownObservable.add(function(coordinates) {
          leftPuck.isVisible = true;
          leftPuck.floatLeft = coordinates.x-(leftThumbContainer._currentMeasure.width*.5)-sideJoystickOffset;
          leftPuck.left = leftPuck.floatLeft;
          leftPuck.floatTop = adt._canvas.height - coordinates.y-(leftThumbContainer._currentMeasure.height*.5)+bottomJoystickOffset;
          leftPuck.top = leftPuck.floatTop*-1;
          leftPuck.isDown = true;
          leftThumbContainer.alpha = 0.9;
      });

      leftThumbContainer.onPointerUpObservable.add(function(coordinates) {
          xAddPos = 0;
          yAddPos = 0;
          leftPuck.isDown = false;
          leftPuck.isVisible = false;
          leftThumbContainer.alpha = 0.4;
      });


      leftThumbContainer.onPointerMoveObservable.add(function(coordinates) {
          if (leftPuck.isDown) {
              xAddPos = coordinates.x-(leftThumbContainer._currentMeasure.width*.5)-sideJoystickOffset;
              yAddPos = adt._canvas.height - coordinates.y-(leftThumbContainer._currentMeasure.height*.5)+bottomJoystickOffset;
              leftPuck.floatLeft = xAddPos;
              leftPuck.floatTop = yAddPos*-1;
              leftPuck.left = leftPuck.floatLeft;
              leftPuck.top = leftPuck.floatTop;
              }
      });

   adt.addControl(leftThumbContainer);
   leftThumbContainer.addControl(leftInnerThumbContainer);
   leftThumbContainer.addControl(leftPuck);
   leftPuck.isVisible = false;

  camera.attachControl(canvas, true);

    scene.registerBeforeRender(function(){
              translateTransform = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(xAddPos/3000, 0, yAddPos/3000), BABYLON.Matrix.RotationY(camera.rotation.y));
              camera.cameraDirection.addInPlace(translateTransform);
              camera.cameraRotation.y += xAddRot/15000*-1;
              camera.cameraRotation.x += yAddRot/15000*-1;
        }); 
</script>
</html>
