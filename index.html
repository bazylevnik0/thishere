<html>
<head>
</head>
<body>
</body>
</body>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            #player {
              position: absolute;
              z-index: 1;
          }
           #rendercanvas {
              position: absolute;
              z-index: 2;
          }

	#upload {
    position: absolute;
    height: 500px;
    top: 500px;
    z-index: 8;
}

	#div_drop {
	position: absolute;
	z-index: 3;
}
	#drop {
	position: absolute;
	z-index: 3;
}


#forward {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 150px;
    left: 50%;
}
#return {
    width: 100px;
    height: 100px;
    position: absolute;
    top: 150px;
    left: 40%;
}


        </style>

        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
	 <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
	<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>

   <body>
<video id="player" controls width="100%" height="100%" autoplay="true"></video>
<script>
  var player = document.getElementById('player');

  var handleSuccess = function(stream) {
    player.srcObject = stream;
  };

  navigator.mediaDevices.getUserMedia({ audio: false, video: true }).then(handleSuccess)
</script>

    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

    <script>

	
        const canvas = document.getElementById("renderCanvas"); // Get the canvas element
        const engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

        // Add your code here matching the playground format

	var scene = new BABYLON.Scene(engine);
       scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
	var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 3, new BABYLON.Vector3(0, 0, 0), scene);
	camera.attachControl(canvas, true);

	var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

	// Register a render loop to repeatedly render the scene
        engine.runRenderLoop(function () {
            	    // Game/Render loop
   	    scene.render();
	
        });

        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
                engine.resize();
        });


	//upload
	function loadFiles () {
		console.log("loadFiles")
	
	//important! we must check real size and correct this 
		//maybe we must correct link obj to mtl
		//if obj not zero element we need find obj!
		BABYLON.SceneLoader.ImportMeshAsync("", files[0].webkitRelativePath , files[0].name).then((result) => {
    		console.log(result.meshes)
		result.meshes[1].scaling.x = 0.25;
    		result.meshes[1].scaling.y = 0.25;
    		result.meshes[1].scaling.z = 0.25;
    		var myMesh1 = scene.getMeshByName("myMesh_1");
		console.log(result)
	})
	
	}
    </script>

<form id="upload" method="post" enctype="multipart/form-data">
 <div>
   <label for="files">Choose file to upload</label>
   <input type="file" id="files" name="files" multiple onchange="readFiles()" webkitrelativepath="true">
 </div>
 <div>
   <button>Submit</button>
 </div>
</form>


<div id="div_drop" ondrop="drop(event)" ondragover="allowDrop(event)"></div>

<img id="drop" src="img_logo.gif" draggable="true" ondragstart="drag(event)" width="336" height="69">

<script>
	 upload_form = document.getElementById('upload');
   
//drag and drop
function allowDrop(ev) {
  ev.preventDefault();
}

function drag(ev) {
  ev.dataTransfer.setData("text", ev.target.id);
}

function drop(ev) {
  ev.preventDefault();
  var data = ev.dataTransfer.getData("text");
  ev.target.appendChild(document.getElementById(data));
}

//input 
var files , reader
function readFiles() {
    console.log("readFiles")
	// this png 
	// this obj
		   //?

    files = document.getElementById('files').files;
    console.log(files)

    let temp;
    for(let i = 0; i < files.length; i++) {
   	console.log(files[i].name , files[i].webkitRelativePath)
    }
  
    editMode();
    loadFiles();
}
</script>
<button id="return" onclick="returnClick()">return</button>
<script>
	let return_button = document.getElementById('return')
	function returnClick() {
  		document.getElementById('files').value = "";
		scene.meshes = scene.meshes.constructor();
		uploadMode();
	}
</script>
<button id="forward" onclick="forwardClick()">return</button>
<script>
	let forward_button = document.getElementById('forward')
	function forwardClick() {
		console.log("forwardClick"); 
	}
</script>
   </body>
<script>
	function editMode() {
		upload_form.style.zIndex=0
		return_button.style.zIndex=8
		forward_button.style.zIndex=8

		    BABYLON.VirtualJoystick.Canvas.style.zIndex = "8";

		console.log("editMode")
	}

	function uploadMode() {
		upload_form.style.zIndex=8
		return_button.style.zIndex=0
		forward_button.style.zIndex=8

		   
		    BABYLON.VirtualJoystick.Canvas.style.zIndex = "0";

		console.log("uploadMode")

	}

//sticks
var leftJoystick = new BABYLON.VirtualJoystick(false);
    var rightJoystick = new BABYLON.VirtualJoystick(true);
    BABYLON.VirtualJoystick.Canvas.style.zIndex = "0";
  var movespeed = 5
  
 scene.onBeforeRenderObservable.add(()=>{
        if(leftJoystick.pressed){
            moveX = leftJoystick.deltaPosition.x * (engine.getDeltaTime()/1000) * movespeed;
            moveZ = leftJoystick.deltaPosition.y * (engine.getDeltaTime()/1000) * movespeed;
          for (let i = 0; i < scene.meshes.length; i++) {
	    scene.meshes[i].rotation.x+=moveX
            scene.meshes[i].rotation.z+=moveZ
	 }            
        }
        if(rightJoystick.pressed){
            moveXX = rightJoystick.deltaPosition.x * (engine.getDeltaTime()/1000) * movespeed;
            moveZZ = rightJoystick.deltaPosition.y * (engine.getDeltaTime()/1000) * movespeed;
         for (let j = 0; j < scene.meshes.length; j++) {
	   scene.meshes[j].position.x+=moveXX
           scene.meshes[j].position.z+=moveZZ
         }
	}
    })

//button
var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    var button1 = BABYLON.GUI.Button.CreateSimpleButton("but1", "Click Me");
    button1.width = "150px"
    button1.height = "40px";
    button1.color = "white";
    button1.top = "600px"
    button1.cornerRadius = 20;
    button1.background = "green";
    button1.onPointerUpObservable.add(function() {
        alert("you did it!");
    });
    advancedTexture.addControl(button1);    

//slider

  

//
 var panel;

var addSlider = function(isVertical, isClamped, displayThumb) {

        var panel = new BABYLON.GUI.StackPanel();

        panel.width = "220px";

        grid.addControl(panel);



        var header = new BABYLON.GUI.TextBlock();

        header.text = "Y-rotation: 0 deg";

        header.height = "30px";

        header.color = "white";

        panel.addControl(header);



        var slider = new BABYLON.GUI.Slider();

        slider.minimum = 0;

        slider.maximum = 2 * Math.PI;

        slider.isThumbClamped = isClamped;

        slider.isVertical = isVertical;

        slider.displayThumb = displayThumb;

        if (isVertical) {

            slider.width = "20px";

            slider.height = "200px";

        } else {

            slider.height = "20px";

            slider.width = "200px";



        }



        slider.color = "red";

        slider.onValueChangedObservable.add(function(value) {

            header.text = "Y-rotation: " + (BABYLON.Tools.ToDegrees(value) | 0) + " deg";

        });



        slider.value = Math.PI + Math.random() * Math.PI;

        panel.addControl(slider);

    }

    var addImageSlider = function(isVertical, isClamped, displayThumb) {

        panel = new BABYLON.GUI.StackPanel();

        panel.width = "220px";

        advancedTexture.addControl(panel);



        var header = new BABYLON.GUI.TextBlock();

        header.text = "Rotation: 0 deg";

        header.height = "30px";

        header.color = "white";

        panel.addControl(header);



        var slider = new BABYLON.GUI.ImageBasedSlider();

        slider.minimum = 0;

        slider.maximum = 2 * Math.PI;

        slider.isVertical = isVertical;

        slider.isThumbClamped = isClamped;

        slider.displayThumb = displayThumb;

        if (isVertical) {

            slider.width = "22px";

            slider.height = "200px";

        } else {

            slider.height = "22px";

            slider.width = "200px";

        }



        if (!isVertical) {

            slider.backgroundImage = new BABYLON.GUI.Image("back", "s.png");

            slider.valueBarImage = new BABYLON.GUI.Image("value", "s.png");

        }

        else {

            slider.backgroundImage = new BABYLON.GUI.Image("back", "s.png");

            slider.valueBarImage = new BABYLON.GUI.Image("value", "s.png");

        }

        slider.thumbImage = new BABYLON.GUI.Image("thumb", "v.png");



        slider.onValueChangedObservable.add(function(value) {

            header.text = "Rotation: " + (BABYLON.Tools.ToDegrees(value) | 0) + " deg";

        });



        slider.value = Math.PI + Math.random() * Math.PI;

        panel.addControl(slider);

    }



addImageSlider(true, true, true );
addImageSlider(true, true, true );


</script>
</html>
