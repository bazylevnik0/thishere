<html>

<head>
</head>

<body>
</body>
</body>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>thishere</title>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #player {
            position: absolute;
            z-index: 1;
        }

        #rendercanvas {
            position: absolute;
            z-index: 2;
        }

        #upload {

	position: absolute;
    z-index: 8;
        }

        #photo {
            width: 100px;
            height: 100px;
            position: absolute;
            bottom: 150px;
            left: 45%;
        }

        #return {
            width: 100px;
            height: 100px;
            position: absolute;
            top: 150px;
            left: 45%;
        }

        #level {
            position: absolute;
            left: 40%;
            top: 50%;
            transform: rotate(270deg);
            width: 100%;
        }

        #size {
            position: absolute;
            right: 40%;
            top: 50%;
            transform: rotate(270deg);
            width: 100%;
        }
    </style>

    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

</head>

<body>
    <video id="player" width="100%" height="100%" autoplay="true"></video>
    <script>
								        //FADEIN FADEOUT animation for UI 
        var player = document.getElementById('player');

        var handleSuccess = function(stream) {
            player.srcObject = stream;
        };
													//ERROR if one camera
        navigator.mediaDevices.enumerateDevices().then(gotDevices).catch(console.log("catch"));

        var cameras_array = []
	let check_back_camera = false;
        function gotDevices(deviceInfos) {
            for (var i = 0; i !== deviceInfos.length; ++i) {
                var deviceInfo = deviceInfos[i];
                if (deviceInfo.kind === 'videoinput') {
		    console.log(deviceInfo.label.toString())
                    if (deviceInfo.label.toString().indexOf('back') !== -1) {
	                check_back_camera = true;
			navigator.mediaDevices.getUserMedia({
                            audio: false,
                            video: {
                                deviceId: deviceInfo.deviceId
                            }
                        }).then(handleSuccess)
                    }
                }
		if ( check_back_camera == false  ) {
               	 	navigator.mediaDevices.getUserMedia({
                    		audio: false,
                    		video: true
                	}).then(handleSuccess)
		}		
            }
	}
    </script>
    <canvas id="renderCanvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->
    <script>
        const canvas = document.getElementById("renderCanvas"); 
        const engine = new BABYLON.Engine(canvas, true); 

        var scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        var camera = new BABYLON.DeviceOrientationCamera("DevOr_camera", new BABYLON.Vector3(0, 0, 0), scene);
        camera.setTarget(new BABYLON.Vector3(0, 0, -10));
        camera.attachControl(canvas, true);

        var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
	
	var sample_tree = [ "./" , "tree.obj"] , sample_tree_check = false
	var sample_book = [ "./" , "book.obj"] , sample_book_check = false

        engine.runRenderLoop(function() {
            scene.render();
        });
    	
	window.addEventListener("resize", function() {
            engine.resize();
        });


        //upload
        var k_size;
        function loadFiles(path,name) {
	    console.log("loadFiles")
 
            BABYLON.SceneLoader.ImportMeshAsync("", path, name).then((result) => {
															//must be dynamic
                switch (name) {
                    case 'tree.obj':
                        k_size = 0.00025;
                        break;
                    case 'book.obj':
                        k_size = 0.0125;
                        break;
                    default:
                        k_size = 1;
                }
                for (let i = 0; i < result.meshes.length; i++) {

                    result.meshes[i].scaling.x = 50 * k_size;
                    result.meshes[i].scaling.y = 50 * k_size;
                    result.meshes[i].scaling.z = 50 * k_size;;

                    result.meshes[i].position.z = -5;

                    var myMesh1 = scene.getMeshByName("myMesh_1");
                    console.log(result)
                }
            })


        }
    </script>

    <form id="upload" method="post" enctype="multipart/form-data">
        <div>
            <label for="files">Choose file to upload</label>
            <input type="file" id="files" name="files" multiple onchange="readFiles()" webkitrelativepath="true">
        </div>
        <div>
            <button>Submit</button>
        </div>
    </form>
    <script>
	let upload_form = document.getElementById('upload')
        var files, reader
        function readFiles() {
	    console.log("readFiles")
            files = document.getElementById('files').files;
 	
	    editMode();
	   if(sample_tree_check) {
		loadFiles(sample_tree[0], sample_tree[1]);
	   } else if(sample_book_check) {
		loadFiles(sample_book[0], sample_book[1]);
	   } else loadFiles(files[0].name, files[0].webkitRelativePath);
       
         }
    </script>
    <button id="return" class="ui" onclick="returnClick()">return</button>
    <script>
        let return_button = document.getElementById('return')

        function returnClick() {
            console.log("returnClick")

            document.getElementById('files').value = "";
            scene.meshes = scene.meshes.constructor();
            uploadMode();
        }
    </script>
    <button id="photo" class="ui" onclick="photoClick()">photo</button>
    <script>
        let ui_classes = document.getElementsByClassName('ui');
        let photo_button = document.getElementById('photo')

        function photoClick() {
            console.log("photoClick");
            for (let i = 0; i < ui_classes.length; i++) {
                ui_classes[i].style.opacity = 0;;
            }

            setTimeout(function() {

                for (let i = 0; i < ui_classes.length; i++) {
                    ui_classes[i].style.opacity = 1;
                }
            }, 1500);

        }
    </script>
    <div class="slidecontainer">
        <input type="range" min="-50" max="50" value="0" class="ui" id="level" oninput="levelChange()">
    </div>
    <script>
        level = document.getElementById('level');
        let level_value;

        function levelChange() {
            console.log("levelChange")

            level_value = level.value;
            for (let i = 0; i < scene.meshes.length; i++) {
                scene.meshes[i].position.y = level_value * 0.2

            }

        }
    </script>
    <div class="slidecontainer">
        <input type="range" min="0" max="100" value="50" class="ui" id="size" oninput="sizeChange()">
    </div>

    <script>
        size = document.getElementById('size');
        let size_value

        function sizeChange() {
            console.log("sizeChange")
            size_value = size.value;
            for (let i = 0; i < scene.meshes.length; i++) {
                scene.meshes[i].scaling.x = size_value * k_size
                scene.meshes[i].scaling.y = size_value * k_size
                scene.meshes[i].scaling.z = size_value * k_size

            }
        }
    </script>
</body>
<script>
    function editMode() {
        upload_form.style.zIndex = 0
        return_button.style.zIndex = 8
        photo_button.style.zIndex = 8
        level.style.zIndex = 8
        size.style.zIndex = 8

        BABYLON.VirtualJoystick.Canvas.style.zIndex = "3";

        console.log("editMode")
    }

    function uploadMode() {
        upload_form.style.zIndex = 8
        return_button.style.zIndex = 0
        photo_button.style.zIndex = 0
        level.style.zIndex = 0
        size.style.zIndex = 0


        BABYLON.VirtualJoystick.Canvas.style.zIndex = "0";

        console.log("uploadMode")

    }

    //sticks
    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    var leftJoystick = new BABYLON.VirtualJoystick(false);
    var rightJoystick = new BABYLON.VirtualJoystick(true);
    BABYLON.VirtualJoystick.Canvas.style.zIndex = "0";

    var movespeed = 2.5

    scene.onBeforeRenderObservable.add(() => {
        if (leftJoystick.pressed) {
            moveXl = leftJoystick.deltaPosition.x * (engine.getDeltaTime() / 1000) * movespeed;
            moveYl = leftJoystick.deltaPosition.y * (engine.getDeltaTime() / 1000) * movespeed;
            for (let i = 0; i < scene.meshes.length; i++) {
                scene.meshes[i].rotation.x += moveXl
                scene.meshes[i].rotation.z += moveYl
            }
        }
        if (rightJoystick.pressed) {
            moveXr = rightJoystick.deltaPosition.x * (engine.getDeltaTime() / 1000) * movespeed;
            moveZr = rightJoystick.deltaPosition.y * (engine.getDeltaTime() / 1000) * movespeed;
            for (let j = 0; j < scene.meshes.length; j++) {
                scene.meshes[j].position.x += moveXr
                scene.meshes[j].position.z += moveZr
            }
        }
    })
</script>

</html>
